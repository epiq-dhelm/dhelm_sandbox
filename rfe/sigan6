#!/bin/python3

#---------Imports
import io
import time
import signal
import serial
import serial.tools.list_ports
import array as arr

from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

import tkinter as tk
from tkinter import ttk
from tkinter import *
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
#---------End of imports



from tkinter import Frame,Label,Entry,Button


GET_CONFIG = "C0"
DO_RESET   = "r"

SERIALPORT = None    #serial port identifier, use None to autodetect
BAUDRATE = 500000

SPAN_SIZE_MHZ = 50           #Initialize settings
START_SCAN_MHZ = 1000
STOP_SCAN_MHZ = START_SCAN_MHZ + SPAN_SIZE_MHZ
SWEEPPOINTS = 112
SWEEPSTEP = SPAN_SIZE_MHZ / SWEEPPOINTS 
print(SWEEPSTEP * 1000000)

STARTFREQ = START_SCAN_MHZ * 1000   #greater than 240M
ENDFREQ = STOP_SCAN_MHZ * 1000
AMPTOP = 0
AMPBOTTOM = -120
CFGAMPBOTTOM = -AMPBOTTOM

RESET = True

config = ['Start_Freq (Khz)\t', 'Freq_Step (Hz)\t\t', 'Amp_Top (dBm)\t\t', 'Amp_Bottom (dBm)\t', 'Sweep_points\t\t', 'ExpModuleActive\t\t', 'CurrentMode\t\t', 'Min_Freq (Khz)\t\t', 'Max_Freq (Khz)\t\t', 'Max_Span (Khz)\t\t', 'RBW (Khz)\t\t', 'AmpOffset (dB)\t\t', 'CalculatorMode \t\t']


cnfg_received = False
model_received = False
reset_received = False

def handler(signum, frame):
    global running

    print("ending...")
    running = False


def SendCommand(port, cmd):
    sCompleteCommand = "#" + chr(len(cmd) + 2) + cmd
    bytestr = sCompleteCommand.encode('utf-8')
    length = port.write(bytestr)
    print("length sent", length)
    print("RFE Command: #(" + str(len(sCompleteCommand)) + ")" + 
            cmd + " [" + " ".join("{:02X}".format(ord(c)) for c in sCompleteCommand) + "]")

def ProcessCommand():
    global running, cnfg_received
    
    try:
        line = port.readline()

    except serial.SerialException as e:
        print('Device error: {}'.format(e))

    cmd = str(line[0:5], 'utf-8', errors='ignore')
    print('cmd: ', cmd, '  len: ',  len(line), " cnfg ", cnfg_received)
    print(line)

    newline = str(line, 'utf-8', errors='ignore')
    print(newline)

    if cmd == '(C) A':
        print('reset received')
        reset_received = True

    if cmd[0:3] == '#Sn':
        serial = newline[3:19]
        print('Serial Number: ' + serial)

    if cmd[0:3] == '#Se':
        eserial = newline[3:19]
        print('Expansion Serial Number: ' + eserial)

    if cmd == '#C2-M':
        model = newline[6:9]
        print('Device Model Received' + model)
        model_received = True
    
    if cmd == '#C2-F':
        listline = newline.replace("#C2-F:", "")
        print('\nCurrent Config')
        mylist = listline.split(",")
        for idx, fname in enumerate(config):
            print(fname, mylist[idx])
        print("\n")

        print("step", mylist[1])

        mystep = int(SWEEPSTEP * 1000000)

        if mystep == int(mylist[1]):
            cnfg_received = True

    #sweep data
    if cmd[0:2] == '$S' and cnfg_received:
#        print("sweep_data")

        newlinelen = len(line) 
        newline = line[3:newlinelen]
        datalen = len(newline) - 2
        data = np.frombuffer(newline, dtype=np.uint8, count=datalen, offset=0)
        newdata = -1 * data

        return True, newdata

    if cmd[0:2] == '$z' :
        print("large sweep")
        newlinelen = len(line) 
        newline = line[4:newlinelen]
        datalen = len(newline) - 2
        data = np.frombuffer(newline, dtype=np.uint8, count=datalen, offset=0)
        newdata = -1 * data
        print(newdata)
        plt.plot(x_axis, newdata)
        plt.pause(0.01)
        if plt.get_fignums():
            running = True
        else:
            running = False


    if cmd[0:2] == '$s': 
        print("ext sweep") 

    return False, 0


class FreqWindow(Toplevel):

    def __init__(self, master = None):

        super().__init__(master = master)
        self.title("Frequency")
        
        curr_x = root.winfo_x()
        curr_y = root.winfo_y()
        
        print(curr_x, curr_y)
        new_x = curr_x + 800
        new_y = curr_y
        geo = "600x200" + '+' + str(new_x) + '+' + str(new_y)
        print(geo)

        self.geometry(geo)
        self.columnconfigure(3, weight=2)
        freqlabel = Label(self, text ="Frequency (MHz): ", font=("Arial", 16));
        freqlabel.grid(row=0, column=0)
        
        self.freqentry = Entry(self, width = 15, font=("Arial", 16))
        center_freq = int(((START_SCAN_MHZ) + (SPAN_SIZE_MHZ / 2)) ) 
        self.freqentry.insert(1, str(center_freq))
        self.freqentry.grid(row=0, column=1)

        spanlabel = Label(self, text ="Span (Mhz): ", font=("Arial", 16));
        spanlabel.grid(row=1, column=0)
        
        self.spanentry = Entry(self, width = 15, font=("Arial", 16))
        span = SPAN_SIZE_MHZ 
        self.spanentry.insert(1, str(span))
        self.spanentry.grid(row=1, column=1)

        enterButton = Button(self, text = 'Enter', font=("Arial", 16), command = self.get_entry)
        enterButton.grid(row=0, column = 3, sticky='e')


    def get_entry(self):
        global START_SCAN_MHZ, STOP_SCAN_MHZ, SPAN_SIZE_MHZ, STARTFREQ, ENDFREQ
        print("get entry")
       
        new_center = int(self.freqentry.get())
        new_span = int(self.spanentry.get())
        print(new_center, new_span)

        START_SCAN_MHZ = int(new_center - (new_span / 2))
        STOP_SCAN_MHZ = int(new_center + (new_span / 2))
        STARTFREQ = START_SCAN_MHZ * 1000   #greater than 240M
        ENDFREQ = STOP_SCAN_MHZ * 1000
        print(START_SCAN_MHZ, STOP_SCAN_MHZ)

        SPAN_SIZE_MHZ = new_span
        app.clear_plot()
        app.build_plot(frame)

class AmpWindow(Toplevel):

    def __init__(self, master = None):

        super().__init__(master = master)
        self.title("Amplitude")
        self.geometry("400x400")
        label = Label(self, text ="This is a new Window")
        label.pack()

class Window(Frame):
    def __init__(self, master = None):
        Frame.__init__(self, master)
        self.master = master

    def animate(self,i):
        self.data_rcvd, self.new_data = ProcessCommand()

        #wait till we get screen data
        while (not self.data_rcvd) and running:
            print("animate wait")
            self.data_rcvd, self.new_data = ProcessCommand()
       
#        print(len(self.new_data), self.new_data)
        self.line.set_ydata(self.new_data)  # update the data

        return self.line,


    def init_comms(self):
        global port
        signal.signal(signal.SIGINT, handler)

        ports = list(serial.tools.list_ports.comports())
        if(ports):
            print("Detected COM ports:")
            for idx, objPort in enumerate(ports):
                print(idx, objPort.device)

        val = input("enter port number")

        port = serial.Serial(ports[int(val)].device, 500000, timeout=5.0)

        print(port.name)


        if RESET:
            #reset device
            cmd = DO_RESET 
            SendCommand(port, cmd)

        while (not reset_received) and running:
            ProcessCommand()

    def init_window(self, content):
        self.objSweep=None
        self.buttonFreq = Button(content,text="Frequency")

        # Following line will bind click event
        # On any click left / right button
        # of mouse a new window will be opened
        self.buttonFreq.bind("<Button>",
                 lambda e: FreqWindow(self.master))

#        self.buttonFreq.grid_columnconfigure(3, weight=1)
#        self.buttonFreq.grid_rowconfigure(0, weight=1)
        self.buttonFreq.grid(row=0,column=3, sticky= 'nsew')

#        self.buttonAmp = Button(content,text="Amplitude", height=10)
        self.buttonAmp = Button(content,text="Amplitude")
        self.buttonAmp.bind("<Button>",
                 lambda e: AmpWindow(self.master))
#        self.buttonAmp.grid_columnconfigure(3, weight=1)
#        self.buttonAmp.grid_rowconfigure(1, weight=1)
        self.buttonAmp.grid(row=1,column=3, sticky='nsew')

        self.fig = plt.Figure()
        self.ax = self.fig.add_subplot(111)
        self.canvas = FigureCanvasTkAgg(self.fig, master=frame)
        self.canvas.get_tk_widget().grid(column=0,row=0, sticky = 'nsew')

    def clear_plot(self):
        self.fig.clf()
        self.ax = self.fig.add_subplot(111)
        self.canvas = FigureCanvasTkAgg(self.fig, master=frame)
        self.canvas.get_tk_widget().grid(column=0,row=0, sticky = 'nsew')

    def build_plot(self, frame):
        global running, cnfg_received, model_received


        #Wait to receive configuration and model details
        while (not model_received) and running:
            ProcessCommand()

        #set config data
        cmd = "C2-F:" + "{:07d}".format(STARTFREQ) + "," + "{:07d}".format(ENDFREQ) + "," + "{:04d}".format(AMPTOP) + "," + "{:04d}".format(CFGAMPBOTTOM)
        SendCommand(port, cmd)

        #Request RF Explorer configuration
        cmd = GET_CONFIG
        SendCommand(port, cmd)
        cnfg_received = False


        #Wait to receive configuration and model details
        while (not cnfg_received) and running:
#            print("waiting for config")
            ProcessCommand()

        if not running:
            exit()


        #Control settings
        print("User settings:" + "Span: " + str(SPAN_SIZE_MHZ) +"MHz"+  
                " - " + "Start freq: " + str(START_SCAN_MHZ) +"MHz"+" - " + 
                "Stop freq: " + str(STOP_SCAN_MHZ) + "MHz")

        SpanSize = SPAN_SIZE_MHZ * 1000000
        StartFreq = START_SCAN_MHZ
        StopFreq = STOP_SCAN_MHZ

        if(SpanSize and StartFreq and StopFreq):
            
            self.x_axis = np.arange(START_SCAN_MHZ , STOP_SCAN_MHZ, SWEEPSTEP, dtype=float)
            nInd = 0
            
            self.data_rcvd, self.new_data = ProcessCommand()

            #wait till we get screen data
            while (not self.data_rcvd) and running:
                self.data_rcvd, self.new_data = ProcessCommand()


            print(len(self.x_axis), self.x_axis, len(self.new_data), self.new_data)

            if (len(self.new_data) > 0):
                self.line, = self.ax.plot(self.x_axis, self.new_data)        
                self.ax.axis([StartFreq, StopFreq, min(self.new_data) - 10, 0 ])
            else: 
                print("somethings wrong")
        else:
            print("Error: settings are wrong.\nPlease, change and try again")

    def go_animate(self):
        self.ani = animation.FuncAnimation(self.fig, self.animate, np.arange(1, 200), interval=25, blit=False)




root = tk.Tk()
root.geometry("800x500")
root.title("sigann")
content = ttk.Frame(root, padding=(3,3,12,12))
frame = ttk.Frame(content, borderwidth=5, relief="ridge", width=200, height=100)

content.grid(column=0, row=0, sticky='nsew')
frame.grid(column=0, row=0, columnspan=3, rowspan=2, sticky='nsew')

root.columnconfigure(0, weight=1)
root.rowconfigure(0, weight=1)
frame.columnconfigure(0, weight=1)
frame.rowconfigure(0, weight=1)
content.columnconfigure(0, weight=3)
content.columnconfigure(1, weight=3)
content.columnconfigure(2, weight=3)
content.columnconfigure(3, weight=1)
content.rowconfigure(0, weight=1)
content.rowconfigure(1, weight=1)


running = True

app = Window(root)
app.init_comms()
app.init_window(content)
app.build_plot(frame)
app.go_animate()
tk.mainloop()
